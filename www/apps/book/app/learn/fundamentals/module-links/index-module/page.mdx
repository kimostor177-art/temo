import { Prerequisites, TypeList } from "docs-ui"

export const metadata = {
  title: `${pageNumber} Index Module`,
}

# {metadata.title}

In this chapter, you'll learn about the Index Module and how you can use it.

<Note type="soon" title="Experimental">

The Index Module is experimental and still in development, so it is subject to change. Consider whether your application can tolerate minor issues before using it in production.

</Note>

## What is the Index Module?

The Index Module is a tool to perform high-performance queries across modules, for example, to filter linked modules.

While modules share the same database by default, Medusa [isolates modules](../../modules/isolation/page.mdx) to allow using external data sources or different database types.

So, when you retrieve data across modules using Query, Medusa aggregates the data coming from different modules to create the end result. This approach limits your ability to filter data by linked modules. For example, you can't filter products (created in the Product Module) by their brand (created in the Brand Module).

The Index Module solves this problem by ingesting data into a central data store on application startup. The data store has a relational structure that enables efficient filtering of data ingested from different modules (and their data stores). So, when you retrieve data with the Index Module, you're retrieving it from the Index Module's data store, not the original data source.

![Diagram showcasing how data is retrieved from the Index Module's data store](https://res.cloudinary.com/dza7lstvk/image/upload/v1747988533/Medusa%20Book/index-module_epurmt.jpg)

### Ingested Data Models

All core data models in Medusa are ingested, including `Product`, `Price`, `SalesChannel`, and more. You can also index custom data models if they are linked to an ingested data model. You'll learn more about this in the [Ingest Custom Data Models](#how-to-ingest-custom-data-models) section.

<Note>

Prior to [Medusa v2.10.2](https://github.com/medusajs/medusa/releases/tag/v2.10.2), only the `Product`, `ProductVariant`, `Price`, and `SalesChannel` data models were ingested. Make sure to update to the latest version to ingest all core data models.

</Note>

---

## How to Install the Index Module

To install the Index Module, run the following command in your Medusa project to install its package:

```bash npm2yarn
npm install @medusajs/index
```

Then, add the Index Module to your Medusa configuration in `medusa-config.ts`:

```ts title="medusa-config.ts"
module.exports = defineConfig({
  // ...
  modules: [
    // ...
    {
      resolve: "@medusajs/index",
    },
  ],
})
```

Finally, run the migrations to create the necessary tables for the Index Module in your database:

```bash
npx medusa db:migrate
```

### Ingest Data

The Index Module only ingests data when you start your Medusa server. So, to ingest the [currently supported data models](#ingested-data-models), start the Medusa application:

```bash npm2yarn
npm run dev
```

The ingestion process may take a while if your product catalog is large. You'll see the following messages in the logs:

```bash
info:    [Index engine] Checking for index changes
info:    [Index engine] Found 7 index changes that are either pending or processing
info:    [Index engine] syncing entity 'ProductVariant'
info:    [Index engine] syncing entity 'ProductVariant' done (+38.73ms)
info:    [Index engine] syncing entity 'Product'
info:    [Index engine] syncing entity 'Product' done (+18.21ms)
info:    [Index engine] syncing entity 'LinkProductVariantPriceSet'
info:    [Index engine] syncing entity 'LinkProductVariantPriceSet' done (+33.87ms)
info:    [Index engine] syncing entity 'Price'
info:    [Index engine] syncing entity 'Price' done (+22.79ms)
info:    [Index engine] syncing entity 'PriceSet'
info:    [Index engine] syncing entity 'PriceSet' done (+10.72ms)
info:    [Index engine] syncing entity 'LinkProductSalesChannel'
info:    [Index engine] syncing entity 'LinkProductSalesChannel' done (+11.45ms)
info:    [Index engine] syncing entity 'SalesChannel'
info:    [Index engine] syncing entity 'SalesChannel' done (+7.00ms)
```

### Update Index on Data Changes

The Index Module automatically updates its data store when data in the ingested data models change. So, you don't need to do anything to keep the data in sync.

For example, if you create a new product, the Index Module will ingest it into its data store.

### Enable Index Module Feature Flag

Since the Index Module is still experimental, the `/store/products` and `/admin/products` API routes will use the Index Module to retrieve products only if the Index Module's feature flag is enabled. By enabling the feature flag, you can filter products by their linked data models in these API routes.

To enable the Index Module's feature flag, add the following line to your `.env` file:

```env
MEDUSA_FF_INDEX_ENGINE=true
```

If you send a request to the `/store/products` or `/admin/products` API routes, you'll receive the following response:

```json
{
  "products": [
    // ...
  ],
  "count": 2,
  "estimate_count": 2,
  "offset": 0,
  "limit": 50
}
```

Notice the `estimate_count` property, which is the estimated total number of products in the database. You'll learn more about it in the [Pagination](#apply-pagination-with-the-index-module) section.

---

## How to Use the Index Module

The Index Module adds a new `index` method to [Query](../query/page.mdx) and it has the same API as the `graph` method.

For example, to filter products by a sales channel ID:

export const basicHighlights = [
  ["17", "id", "Filter products by their linked sales channel ID."]
]

```ts title="src/api/custom/products/route.ts" highlights={basicHighlights}
import {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"

export const GET = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const query = req.scope.resolve("query")
  
  const { data: products } = await query.index({
    entity: "product",
    fields: ["*", "sales_channels.*"],
    filters: {
      sales_channels: {
        id: "sc_123",
      },
    },
  })

  res.json({ products })
}
```

This will return all products that are linked to the sales channel with the ID `sc_123`.

The `index` method accepts an object with the same properties as the `graph` method's parameter:

- `entity`: The data model's name, as specified in the first parameter of the `model.define` method used for the data model's definition.
- `fields`: An array of the data modelâ€™s properties, relations, and linked data models to retrieve in the result.
- `filters`: An object with the filters to apply on the data model's properties, relations, and linked data models that are ingested.

---

## How to Ingest Custom Data Models

Aside from the [core data models](#ingested-data-models), you can also ingest your own custom data models into the Index Module. You can do so by defining a link between your custom data model and one of the core data models, and setting the `filterable` property in the link definition.

<Note>

Read-only links are not supported by the Index Module.

</Note>

For example, assuming you have a Brand Module with a Brand data model (as explained in the [Customizations](../../../customization/custom-features/module/page.mdx)), you can ingest it into the Index Module using the `filterable` property in its link definition to the Product data model:

export const filterableHighlights = [
  ["12", "filterable", "Ingest Brand by setting its filterable properties."]
]

```ts title="src/links/product-brand.ts" highlights={filterableHighlights}
import BrandModule from "../modules/brand"
import ProductModule from "@medusajs/medusa/product"
import { defineLink } from "@medusajs/framework/utils"

export default defineLink(
  {
    linkable: ProductModule.linkable.product,
    isList: true,
  },
  {
    linkable: BrandModule.linkable.brand,
    filterable: ["id", "name"],
  }
)
```

The `filterable` property is an array of property names in the data model that can be filtered using the `index` method. When the `filterable` property is set, the Index Module will ingest into its data store the custom data model.

But first, you must run the migrations to sync the link, then start the Medusa application:

```bash npm2yarn
npx medusa db:migrate
npm run dev
```

You'll then see the following message in the logs:

```bash
info:    [Index engine] syncing entity 'LinkProductProductBrandBrand'
info:    [Index engine] syncing entity 'LinkProductProductBrandBrand' done (+3.64ms)
info:    [Index engine] syncing entity 'Brand'
info:    [Index engine] syncing entity 'Brand' done (+0.99ms)
```

You can now filter products by their brand, and vice versa. For example:

```ts title="src/api/custom/products/route.ts"
import {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"

export const GET = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const query = req.scope.resolve("query")
  
  const { data: products } = await query.index({
    entity: "product",
    fields: ["*", "brand.*"],
    filters: {
      brand: {
        name: "Acme",
      },
    },
  })

  res.json({ products })
}
```

This will return all products that are linked to the brand with the name `Acme`. For example:

```json title="Example Response"
{
  "products": [
    {
      "id": "prod_123",
      "brand": {
        "id": "brand_123",
        "name": "Acme"
      },
      // ...
    }
  ]
}
```

---

## Apply Pagination with the Index Module

Similar to Query's `graph` method, the Index Module accepts a `pagination` object to paginate the results.

For example, to paginate the products and retrieve `10` products per page:

export const paginationHighlights = [
  ["14", "metadata", "Pagination details."],
  ["23", "pagination", "Apply pagination to the retrieved records."]
]

```ts title="src/api/custom/products/route.ts" highlights={paginationHighlights}
import {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"

export const GET = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const query = req.scope.resolve("query")
  
  const { 
    data: products,
    metadata,
  } = await query.index({
    entity: "product",
    fields: ["*", "brand.*"],
    filters: {
      brand: {
        name: "Acme",
      },
    },
    pagination: {
      take: 10,
      skip: 0,
    },
  })

  res.json({ products, ...metadata })
}
```

The `pagination` object accepts the following properties:

- `take`: The number of items to retrieve per page.
- `skip`: The number of items to skip before retrieving the items.

When the `pagination` property is set, the `index` method will also return a `metadata` property. `metadata` is an object with the following properties:

- `skip`: The number of items skipped.
- `take`: The number of items retrieved.
- `estimate_count`: The estimated total number of items in the database matching the query. This value is retrieved from the PostgreSQL query planner rather than using a `COUNT` query, so it may not be accurate for smaller data sets.

For example, this is the response returned by the above API route:

```json title="Example Response"
{
  "products": [
    // ...
  ],
  "skip": 0,
  "take": 10,
  "estimate_count": 100
}
```

---

## Cache Index Module Results

<Prerequisites
  items={[
    {
      text: "Caching Module installed with a provider.",
      link: "!resources!/infrastructure-modules/caching#install-the-caching-module"
    }
  ]}
/>

<Note>

Caching options are available from [Medusa v2.11.0](https://github.com/medusajs/medusa/releases/tag/v2.11.0).

</Note>

You can cache Index Module results to improve performance and reduce database load. To do that, you can pass a `cache` property in the second parameter of the `query.index` method.

For example, to enable caching for a query:

```ts highlights={[["6", "enable", "Enable caching for this query."]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true
  }
})
```

In this example, you enable caching of the query's results. The next time the same query is executed, the results are returned from the cache instead of querying the database.

<Note title="Tip">

Refer to the [Caching Module documentation](!resources!/infrastructure-modules/caching/concepts#caching-best-practices) for best practices on caching.

</Note>

### Cache Properties

`cache` is an object that accepts the following properties:

<TypeList
  types={[
    {
      type: "`boolean` \| `((args: any[]) => boolean \| undefined)`",
      name: "enable",
      description: "Whether to enable caching of query results. If a function is passed, it receives as a parameter the `query.index` parameters, and returns a boolean indicating whether caching is enabled.",
      defaultValue: "false"
    },
    {
      type: "`string` \| `((args: any[], cachingModule: ICachingModuleService) => string \| Promise<string>)`",
      name: "key",
      description: "The key to cache the query results with.  If no key is provided, the Caching Module will generate the key from the `query.index` parameters.\n\nIf a function is passed, it receives the following properties:\n\n1. The parameters passed to `query.index`.\n\n2. The [Caching Module's service](!resources!/references/caching-service), which you can use to perform caching operations.\n\nThe function must return a string indicating the cache key.",
    },
    {
      type: "`string[]` \| `((args: any[]) => string[] \| undefined)`",
      name: "tags",
      description: "The tags to associate with the cached results. Tags are useful to group related items. If no tag is provided, the Caching Module will generate relevant tags based on the entity and its retrieved relations.\n\nIf a function is passed, it receives as a parameter the `query.index` parameters, and returns an array of strings indicating the cache tags."
    },
    {
      type: "`number` \| `((args: any[]) => number \| undefined)`",
      name: "ttl",
      description: "The time-to-live (TTL) for the cached results, in seconds. If no TTL is provided, the Caching Module Provider will receive the [configured TTL of the Caching Module](!resources!/infrastructure-modules/caching#caching-module-options), or it will use its own default value.\n\nIf a function is passed, it receives as a parameter the `query.index` parameters, and returns a number indicating the TTL.",
    },
    {
      type: "`boolean` \| `((args: any[]) => boolean \| undefined)`",
      name: "autoInvalidate",
      description: "Whether to automatically invalidate the cached data when it expires.\n\nIf a function is passed, it receives as a parameter the `query.index` parameters, and returns a boolean indicating whether to automatically invalidate the cache.",
      defaultValue: "`true`"
    },
    {
      type: "`string[]` \| `((args: any[]) => string[] \| undefined)`",
      name: "providers",
      description: "The IDs of the providers to use for caching. If not provided, the [default Caching Module Provider](!resources!/infrastructure-modules/caching/providers#default-caching-module-provider) is used. If multiple providers are passed, the cache is stored and retrieved in those providers in order.\n\nIf a function is passed, it receives as a parameter the `query.index` parameters, and return an array of strings indicating the providers to use."
    }
  ]}
  sectionTitle="Cache Properties"
/>

### Set Cache Key

By default, the Caching Module generates a cache key for a query based on the arguments passed to `query.index`. The cache key is a unique key that the cached result is stored with.

Alternatively, you can set a custom cache key for a query. This is useful if you want to manage invalidating the cache manually.

To set the cache key of a query, pass the `cache.key` option:

```ts highlights={[["7"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    key: "products-123456",
    // to disable auto invalidation:
    // autoInvalidate: false,
  }
})
```

In the example above, you cache the query results with the `products-123456` key.

<Note>

You should generate cache keys with the Caching Module service's [computeKey method](!resources!/references/caching-service#computeKey) to ensure that the key is unique and follows best practices.

</Note>

You can also pass a function as the value of `cache.key`:

```ts highlights={[["7"], ["8"], ["9"], ["10"], ["11"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    key: async (args, cachingModuleService) => {
      return await cachingModuleService.computeKey({
        ...args,
        prefix: "products"
      })
    }
  }
})
```

In the example above, you pass a function to `key`. It accepts two parameters:

1. The arguments of `query.index` passed as an array.
2. The [Caching Module's service](!resources!/references/caching-service).

You generate the key using the [computeKey method of the Caching Module's service](!resources!/references/caching-service#computeKey). The query results will be cached with that key.

### Set Cache Tags

By default, the Caching Module generates relevant tags for a query based on the entity and its retrieved relations. Cache tags are useful to group related items together, allowing you to [retrieve](!resources!/references/caching-service#get) or [invalidate](!resources!/references/caching-service#clear) items by common tags.

Alternatively, you can set the cache tags of a query manually. This is useful if you want to manage invalidating the cache manually, or you want to group related cached items with custom tags.

To set the cache tags of a query, pass the `cache.tags` option:

```ts highlights={[["7"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    tags: ["Product:list:*"],
  }
})
```

In the example above, you cache the query results with the `Product:list:*` tag.

<Note>

The cache tag must follow the [Caching Tags Convention](!resources!/infrastructure-modules/caching/concepts#caching-tags-convention) to be automatically invalidated.

</Note>

You can also pass a function as the value of `cache.tags`:

```ts highlights={[["7"], ["8"], ["9"], ["10"], ["11"], ["12"], ["13"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    tags: (args) => {
      const collectionId = args[0].filter?.collection_id
      return [
        ...args,
        collectionId ? `ProductCollection:${collectionId}` : undefined,
      ]
    },
  }
})
```

In the example above, you use a function to determine the cache tags. The function accepts the arguments passed to `query.index` as an array.

Then, you add the `ProductCollection:id` tag if `collection_id` is passed in the query filters.

### Set TTL

By default, the Caching Module will pass the [configured time-to-live (TTL)](!resources!/infrastructure-modules/caching#caching-module-options) to the Caching Module Provider when caching data. The Caching Module Provider may also have its own default TTL.  The cache isn't invalidated until the configured TTL passes.

Alternatively, you can set a custom TTL for a query. This is useful if you want the cached data to be invalidated sooner or later than the default TTL.

To set the TTL of the cached query results to a custom value, use the `cache.ttl` option:

```ts highlights={[["7"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    ttl: 100, // 100 seconds
  }
})
```

In the example above, you set the TTL of the cached query result to `100` seconds. It will be invalidated after that time.

You can also pass a function as the value of `cache.ttl`:

```ts highlights={[["10"], ["11"], ["12"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
  filters: {
    id: "prod_123"
  }
}, {
  cache: {
    enable: true,
    ttl: (args) => {
      return args[0].filters.id === "test" ? 10 : 100
    }
  }
})
```

In the example above, you use a function to determine the TTL. The function accepts the arguments passed to `query.index` as an array.

Then, you set the TTL based on the ID of the product passed in the filters.

### Set Auto Invalidation

By default, the Caching Module automatically invalidates cached query results when the data changes.

Alternatively, you can disable auto invalidation of cached query results. This is useful if you want to manage invalidating the cache manually.

To configure invalidation behavior, use the `cache.autoInvalidate` option:

```ts highlights={[["7"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    autoInvalidate: false,
  }
})
```

In this example, you disable auto invalidation of the query result. You must [invalidate](!resources!/references/caching-service#clear) the cached data manually.

You can also pass a function as the value of `cache.autoInvalidate`:

```ts highlights={[["7"], ["8"], ["9"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    autoInvalidate: (args) => {
      return !args[0].fields.includes("custom_field")
    }
  }
})
```

In the example above, you use a function to determine whether to invalidate the cached query result automatically. The function accepts the arguments passed to `query.index` as an array.

Then, you enable auto-invalidation only if the `fields` passed to `query.index` don't include `custom_fields`. If this disables auto-invalidation, you must [invalidate](!resources!/references/caching-service#clear) the cached data manually.

<Note title="Tip">

Learn more about automatic invalidation in the [Caching Module documentation](!resources!/infrastructure-modules/caching/concepts#automatic-cache-invalidation).

</Note>

### Set Caching Provider

By default, the Caching Module uses the [default Caching Module Provider](!resources!/infrastructure-modules/caching/providers#default-caching-module-provider) to cache a query.

Alternatively, you can set the caching provider to use for a query. This is useful if you have multiple caching providers configured, and you want to use a specific one for a query, or you want to specify a fallback provider.

To configure the caching providers, use the `cache.providers` option:

```ts highlights={[["7"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
}, {
  cache: {
    enable: true,
    providers: ["caching-redis", "caching-memcached"]
  }
})
```

In the example above, you specify the providers with ID `caching-redis` and `caching-memcached` to cache the query results. These IDs must match the IDs of the providers in `medusa-config.ts`.

When you pass multiple providers, the cache is stored and retrieved in those providers in order.

You can also pass a function as the value of `cache.providers`:

```ts highlights={[["10"], ["11"], ["12"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["id", "title"],
  filters: {
    id: "prod_123"
  }
}, {
  cache: {
    enable: true,
    providers: (args) => {
      return args[0].filters.id === "test" ? ["caching-redis"] : ["caching-memcached"]
    }
  }
})
```

In the example above, you use a function to determine the caching providers. The function accepts the arguments passed to `query.index` as an array.

Then, you set the providers based on the ID of the product passed in the filters.

---

## index Method Usage Examples

The following sections show examples of how to use the `index` method in different scenarios.

### Retrieve Linked Data Models

Retrieve the records of a linked data model by passing in fields the data model's name suffixed with `.*`.

For example:

```ts title="src/api/custom/products/route.ts" highlights={[["3"]]}
const { data: products } = await query.index({
  entity: "product",
  fields: ["*", "brand.*"],
})
```

This will return all products with their linked brand data model.

### Use Advanced Filters

When setting filters on properties, you can use advanced filters like `$ne` and `$gt`. These are the same advanced filters accepted by the [listing methods generated by the Service Factory](!resources!/service-factory-reference/tips/filtering).

For example, to only retrieve products linked to a brand:

```ts title="src/api/custom/products/route.ts" highlights={[["9"]]}
const { 
  data: products,
} = await query.index({
  entity: "product",
  fields: ["*", "brand.*"],
  filters: {
    brand: {
      id: {
        $ne: null,
      },
    },
  },
})
```

You use the `$ne` operator to filter products that are linked to a brand.

Another example is to retrieve products whose brand name starts with `Acme`:

```ts title="src/api/custom/products/route.ts" highlights={[["9"]]}
const { 
  data: products,
} = await query.index({
  entity: "product",
  fields: ["*", "brand.*"],
  filters: {
    brand: {
      name: {
        $like: "Acme%",
      },
    },
  },
})
```

This will return all products whose brand name starts with `Acme`.

### Use Request Query Configurations

API routes using the `graph` method can configure default [query configurations](../query/page.mdx#request-query-configurations), such as which fields to retrieve, while also allowing clients to override them using query parameters.

The `index` method supports the same configurations. For example, if you add the request query configuration as explained in the [Query documentation](../query/page.mdx#request-query-configurations), you can use those configurations in the `index` method:

```ts title="src/api/custom/products/route.ts" highlights={[["17"]]}
import {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"

export const GET = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const query = req.scope.resolve("query")
  
  const { 
    data: products,
    metadata,
  } = await query.index({
    entity: "product",
    ...req.queryConfig,
    filters: {
      brand: {
        name: "Acme",
      },
    },
  })

  res.json({ products, ...metadata })
}
```

You pass the `req.queryConfig` object to the `index` method, which will contain the fields and pagination properties to use in the query.

### Use Index Module in Workflows

In a workflow's step, you can resolve `query` and use its `index` method to retrieve data using the Index Module.

For example:

export const workflowHighlights = [
  ["11", "query", "Resolve query in a workflow step."],
  ["13", "index", "Use the `index` method to retrieve data."],
]

```ts title="src/workflows/custom-workflow.ts" highlights={workflowHighlights}
import {
  createStep,
  createWorkflow,
  StepResponse,
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk"

const retrieveBrandsStep = createStep(
  "retrieve-brands",
  async ({}, { container }) => {
    const query = container.resolve("query")

    const { data: brands } = await query.index({
      entity: "brand",
      fields: ["*", "products.*"],
      filters: {
        products: {
          id: {
            $ne: null,
          },
        },
      },
    })

    return new StepResponse(brands)
  }
)

export const retrieveBrandsWorkflow = createWorkflow(
  "retrieve-brands",
  () => {
    const retrieveBrands = retrieveBrandsStep()

    return new WorkflowResponse(retrieveBrands)
  }
)
```

This will retrieve all brands that are linked to at least one product.
